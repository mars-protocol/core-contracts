{
  "contract_name": "mars-perps",
  "contract_version": "2.2.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The perp protocol's global configuration",
    "type": "object",
    "required": [
      "address_provider",
      "base_denom",
      "cooldown_period",
      "deleverage_enabled",
      "max_positions",
      "max_unlocks",
      "protocol_fee_rate",
      "target_vault_collateralization_ratio",
      "vault_withdraw_enabled"
    ],
    "properties": {
      "address_provider": {
        "description": "Address provider returns addresses for all protocol contracts",
        "type": "string"
      },
      "base_denom": {
        "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
        "type": "string"
      },
      "cooldown_period": {
        "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "deleverage_enabled": {
        "description": "If the collateralization ratio of the vault falls below the target_vault_collateralization_ratio, it is eligible to be deleveraged when this parameter is true.",
        "type": "boolean"
      },
      "max_positions": {
        "description": "The maximum number of positions that can be opened by a single user",
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "max_unlocks": {
        "description": "The maximum number of unlocks that can be requested by a single user",
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "protocol_fee_rate": {
        "description": "The percentage of fees that is directed to the protocol",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "target_vault_collateralization_ratio": {
        "description": "The target collateralization ratio of the vault",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "vault_withdraw_enabled": {
        "description": "True by default, it can be set to false to disable perp counterparty vault withdrawals",
        "type": "boolean"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "update_owner"
        ],
        "properties": {
          "update_owner": {
            "$ref": "#/definitions/OwnerUpdate"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Provide liquidity of the base token to the vault.\n\nMust send exactly one coin of `base_denom`.\n\nThe deposited tokens will be used to settle perp trades. liquidity providers win if traders have negative PnLs, or loss if traders have positive PnLs.",
        "type": "object",
        "required": [
          "deposit"
        ],
        "properties": {
          "deposit": {
            "type": "object",
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "max_shares_receivable": {
                "description": "The maximum amount of shares received from the deposit action. This allows the user to protect themselves from unexpected slippage or directional exposure that can result from the vault having a negative PNL. If not provided, defaults to zero.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unlock liquidity from the vault. The unlocked tokens will have to wait a cooldown period before they can be withdrawn.",
        "type": "object",
        "required": [
          "unlock"
        ],
        "properties": {
          "unlock": {
            "type": "object",
            "required": [
              "shares"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "shares": {
                "description": "The amount of shares to unlock",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw liquidity from the vault.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "min_receive": {
                "description": "The minimum amount of base token to recieve from the withdraw action. Provided to protect user from unexpected slippage. If not provided, defaults to zero.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Execute a perp order against a perp market for a given account. If the position in that market for that account id exists, it is modified. If no position exists, a position is created (providing reduce_only is none or false)",
        "type": "object",
        "required": [
          "execute_order"
        ],
        "properties": {
          "execute_order": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "size"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "reduce_only": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "size": {
                "$ref": "#/definitions/Int128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Close all perp positions. Use this to liquidate a user's credit account.\n\nOnly callable by Rover credit manager.",
        "type": "object",
        "required": [
          "close_all_positions"
        ],
        "properties": {
          "close_all_positions": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Deleveraging a vault by closing a position for an account. This process helps to increase the Collateralization Ratio (CR) of the vault and/or decrease the maximum Open Interest (max OI) values (`long_oi_value` and `short_oi_value`).\n\nThe highest unrealized PnL should be closed first. In cases where the maximum OI is exceeded, prioritize closing the most profitable position that contributes to the exceeded OI (e.g., if long OI is exceeded, close the most profitable long position).",
        "type": "object",
        "required": [
          "deleverage"
        ],
        "properties": {
          "deleverage": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Receive updated parameters from the params contract",
        "type": "object",
        "required": [
          "update_market"
        ],
        "properties": {
          "update_market": {
            "type": "object",
            "required": [
              "params"
            ],
            "properties": {
              "params": {
                "$ref": "#/definitions/PerpParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the contract's global configuration",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "updates"
            ],
            "properties": {
              "updates": {
                "$ref": "#/definitions/ConfigUpdates"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ActionKind": {
        "description": "Differentiator for the action (liquidate, withdraw, borrow etc.) being performed.",
        "type": "string",
        "enum": [
          "default",
          "liquidation"
        ]
      },
      "ConfigUpdates": {
        "type": "object",
        "properties": {
          "address_provider": {
            "type": [
              "string",
              "null"
            ]
          },
          "cooldown_period": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "deleverage_enabled": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "max_positions": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint8",
            "minimum": 0.0
          },
          "max_unlocks": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint8",
            "minimum": 0.0
          },
          "protocol_fee_rate": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "target_vault_collateralization_ratio": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "vault_withdraw_enabled": {
            "type": [
              "boolean",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Int128": {
        "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
        "type": "string"
      },
      "OwnerUpdate": {
        "oneOf": [
          {
            "description": "Proposes a new owner to take role. Only current owner can execute.",
            "type": "object",
            "required": [
              "propose_new_owner"
            ],
            "properties": {
              "propose_new_owner": {
                "type": "object",
                "required": [
                  "proposed"
                ],
                "properties": {
                  "proposed": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Clears the currently proposed owner. Only current owner can execute.",
            "type": "string",
            "enum": [
              "clear_proposed"
            ]
          },
          {
            "description": "Promotes the proposed owner to be the current one. Only the proposed owner can execute.",
            "type": "string",
            "enum": [
              "accept_proposed"
            ]
          },
          {
            "description": "Throws away the keys to the Owner role forever. Once done, no owner can ever be set later.",
            "type": "string",
            "enum": [
              "abolish_owner_role"
            ]
          },
          {
            "description": "A separate entity managed by Owner that can be used for granting specific emergency powers.",
            "type": "object",
            "required": [
              "set_emergency_owner"
            ],
            "properties": {
              "set_emergency_owner": {
                "type": "object",
                "required": [
                  "emergency_owner"
                ],
                "properties": {
                  "emergency_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove the entity in the Emergency Owner role",
            "type": "string",
            "enum": [
              "clear_emergency_owner"
            ]
          }
        ]
      },
      "PerpParams": {
        "type": "object",
        "required": [
          "closing_fee_rate",
          "denom",
          "enabled",
          "liquidation_threshold",
          "max_funding_velocity",
          "max_loan_to_value",
          "max_long_oi_value",
          "max_net_oi_value",
          "max_short_oi_value",
          "min_position_value",
          "opening_fee_rate",
          "skew_scale"
        ],
        "properties": {
          "closing_fee_rate": {
            "description": "The fee paid by the user to close a position (as a percent)",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "denom": {
            "description": "Perp denomination",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the perp is enabled",
            "type": "boolean"
          },
          "liquidation_threshold": {
            "description": "LTV at which a position becomes liquidatable",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "liquidation_threshold_usdc": {
            "description": "LTV at which a position becomes liquidatable for USDC margin accounts.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_funding_velocity": {
            "$ref": "#/definitions/Decimal"
          },
          "max_loan_to_value": {
            "description": "Max loan to position value for the position.",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "max_loan_to_value_usdc": {
            "description": "Max loan to position value for the position for USDC margin accounts.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_long_oi_value": {
            "description": "The maximum long open interest value (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_net_oi_value": {
            "description": "The maximum net open interest value (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "max_position_value": {
            "description": "The maximum value of a position (in oracle uusd denomination)",
            "anyOf": [
              {
                "$ref": "#/definitions/Uint128"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_short_oi_value": {
            "description": "The maximum short open interest value (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "min_position_value": {
            "description": "The minimum value of a position (in oracle uusd denomination)",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "opening_fee_rate": {
            "description": "The fee paid by the user to open a position (as a percent)",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          },
          "skew_scale": {
            "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Query the owner of the contract.",
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the current configuration of the contract.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the vault state, optionally for a specific action.",
        "type": "object",
        "required": [
          "vault"
        ],
        "properties": {
          "vault": {
            "type": "object",
            "properties": {
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the state of a specific market.",
        "type": "object",
        "required": [
          "market_state"
        ],
        "properties": {
          "market_state": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single market.",
        "type": "object",
        "required": [
          "market"
        ],
        "properties": {
          "market": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query markets with pagination.",
        "type": "object",
        "required": [
          "markets"
        ],
        "properties": {
          "markets": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the vault position for a specific user and optional account id.",
        "type": "object",
        "required": [
          "vault_position"
        ],
        "properties": {
          "vault_position": {
            "type": "object",
            "required": [
              "user_address"
            ],
            "properties": {
              "account_id": {
                "description": "The user's credit account token ID. If account id is provided Credit Manager calls the contract, otherwise a wallet.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "user_address": {
                "description": "User address calling the contract. It can be the Credit Manager contract or a wallet.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query a single perp position by account and denom.",
        "type": "object",
        "required": [
          "position"
        ],
        "properties": {
          "position": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "order_size": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Int128"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "reduce_only": {
                "type": [
                  "boolean",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all accounts and denoms.",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List positions of all denoms that belong to a specific credit account.\n\nNOTE: This query does not take a pagination parameter. It always returns _all_ perp positions that belong to the given account.",
        "type": "object",
        "required": [
          "positions_by_account"
        ],
        "properties": {
          "positions_by_account": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "action": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ActionKind"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query realized PnL amounts for a specific account and market.",
        "type": "object",
        "required": [
          "realized_pnl_by_account_and_market"
        ],
        "properties": {
          "realized_pnl_by_account_and_market": {
            "type": "object",
            "required": [
              "account_id",
              "denom"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the accounting details for a specific market.",
        "type": "object",
        "required": [
          "market_accounting"
        ],
        "properties": {
          "market_accounting": {
            "type": "object",
            "required": [
              "denom"
            ],
            "properties": {
              "denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the total accounting details across all markets.",
        "type": "object",
        "required": [
          "total_accounting"
        ],
        "properties": {
          "total_accounting": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the opening fee for a given market and position size.",
        "type": "object",
        "required": [
          "opening_fee"
        ],
        "properties": {
          "opening_fee": {
            "type": "object",
            "required": [
              "denom",
              "size"
            ],
            "properties": {
              "denom": {
                "type": "string"
              },
              "size": {
                "$ref": "#/definitions/Int128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the fees associated with modifying a specific position.",
        "type": "object",
        "required": [
          "position_fees"
        ],
        "properties": {
          "position_fees": {
            "type": "object",
            "required": [
              "account_id",
              "denom",
              "new_size"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "denom": {
                "type": "string"
              },
              "new_size": {
                "$ref": "#/definitions/Int128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ActionKind": {
        "description": "Differentiator for the action (liquidate, withdraw, borrow etc.) being performed.",
        "type": "string",
        "enum": [
          "default",
          "liquidation"
        ]
      },
      "Int128": {
        "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config_for_String",
      "description": "The perp protocol's global configuration",
      "type": "object",
      "required": [
        "address_provider",
        "base_denom",
        "cooldown_period",
        "deleverage_enabled",
        "max_positions",
        "max_unlocks",
        "protocol_fee_rate",
        "target_vault_collateralization_ratio",
        "vault_withdraw_enabled"
      ],
      "properties": {
        "address_provider": {
          "description": "Address provider returns addresses for all protocol contracts",
          "type": "string"
        },
        "base_denom": {
          "description": "The token used to settle perp trades.\n\nTypically, this is be a stablecoin such as USDC (more precisely, the IBC voucher denom of USDC).\n\nLiquidity providers deposit this token to the vault. Traders deposit this token as collateral when opening perp positions.\n\nWhen closing a winning perp position (one that has a positive unrealized PnL), this token (of the amount corresponding to the PnL) is transferred from the vault to the user's credit account, together with the originally deposited collateral.\n\nConversely, when closing a losing position, this token (of amount corresponding to the PnL) is transferred from the user's position to the vault. The remaining amount is refunded to the uesr's credit account.",
          "type": "string"
        },
        "cooldown_period": {
          "description": "Stakers need to wait a cooldown period before being able to withdraw USDC from the vault. Value defined in seconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "deleverage_enabled": {
          "description": "If the collateralization ratio of the vault falls below the target_vault_collateralization_ratio, it is eligible to be deleveraged when this parameter is true.",
          "type": "boolean"
        },
        "max_positions": {
          "description": "The maximum number of positions that can be opened by a single user",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "max_unlocks": {
          "description": "The maximum number of unlocks that can be requested by a single user",
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "protocol_fee_rate": {
          "description": "The percentage of fees that is directed to the protocol",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "target_vault_collateralization_ratio": {
          "description": "The target collateralization ratio of the vault",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "vault_withdraw_enabled": {
          "description": "True by default, it can be set to false to disable perp counterparty vault withdrawals",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "market": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MarketResponse",
      "description": "Market state for a single denom",
      "type": "object",
      "required": [
        "current_funding_rate",
        "denom",
        "enabled",
        "long_oi",
        "long_oi_value",
        "short_oi",
        "short_oi_value"
      ],
      "properties": {
        "current_funding_rate": {
          "description": "Current funding rate",
          "allOf": [
            {
              "$ref": "#/definitions/SignedDecimal"
            }
          ]
        },
        "denom": {
          "description": "Denomination of the asset",
          "type": "string"
        },
        "enabled": {
          "description": "Enabled status of the market",
          "type": "boolean"
        },
        "long_oi": {
          "description": "Total LONG open interest in utokens",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "long_oi_value": {
          "description": "Total LONG open interest in oracle base currency (uusd)",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "short_oi": {
          "description": "Total SHORT open interest in utokens",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "short_oi_value": {
          "description": "Total SHORT open interest in oracle base currency (uusd)",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "SignedDecimal": {
          "description": "A signed fixed-point decimal value with 18 fractional digits, i.e. SignedDecimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 170141183460469231731.687303715884105727 (which is (2^127 - 1) / 10^18) and the smallest is -170141183460469231731.687303715884105728 (which is -2^127 / 10^18).",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "market_accounting": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AccountingResponse",
      "description": "Represents the vault's accounting data and unrealized profit and loss (PnL), all denominated in the base currency (e.g. UUSDC).",
      "type": "object",
      "required": [
        "accounting",
        "unrealized_pnl"
      ],
      "properties": {
        "accounting": {
          "description": "The vault's accounting data. Negative values indicate the vault is losing money, meaning traders are in profit.",
          "allOf": [
            {
              "$ref": "#/definitions/Accounting"
            }
          ]
        },
        "unrealized_pnl": {
          "description": "Unrealized PnL amounts for all open positions. Negative unrealized PnL indicates traders are losing money, meaning the vault is in profit.",
          "allOf": [
            {
              "$ref": "#/definitions/PnlAmounts"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Accounting": {
          "description": "Represents the accounting data for the vault, denominated in the base currency (e.g. UUSDC). If the values are negative, it indicates the vault is losing money.",
          "type": "object",
          "required": [
            "balance",
            "cash_flow",
            "withdrawal_balance"
          ],
          "properties": {
            "balance": {
              "description": "The total balance, which includes both realized and unrealized amounts.",
              "allOf": [
                {
                  "$ref": "#/definitions/Balance"
                }
              ]
            },
            "cash_flow": {
              "description": "The realized amount of money, only includes completed payments.",
              "allOf": [
                {
                  "$ref": "#/definitions/CashFlow"
                }
              ]
            },
            "withdrawal_balance": {
              "description": "The amount available for withdrawal by liquidity providers (LPs). This value may cap certain unrealized payments.",
              "allOf": [
                {
                  "$ref": "#/definitions/Balance"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Balance": {
          "description": "Amount of money denominated in the base denom (e.g. UUSDC) used for accounting",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "total"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            },
            "total": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        },
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "protocol_fee"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            },
            "protocol_fee": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/Int128"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "market_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MarketStateResponse",
      "description": "Global state of a single denom",
      "type": "object",
      "required": [
        "cash_flow",
        "denom",
        "enabled",
        "funding",
        "last_updated",
        "long_oi",
        "short_oi",
        "total_abs_multiplied_positions",
        "total_entry_cost",
        "total_entry_funding",
        "total_squared_positions"
      ],
      "properties": {
        "cash_flow": {
          "description": "The actual amount of money, includes only realized payments",
          "allOf": [
            {
              "$ref": "#/definitions/CashFlow"
            }
          ]
        },
        "denom": {
          "type": "string"
        },
        "enabled": {
          "description": "Whether the denom is enabled for trading",
          "type": "boolean"
        },
        "funding": {
          "description": "Funding parameters for this denom",
          "allOf": [
            {
              "$ref": "#/definitions/Funding"
            }
          ]
        },
        "last_updated": {
          "description": "The last time this denom was updated",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "long_oi": {
          "description": "Total LONG open interest",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "short_oi": {
          "description": "Total SHORT open interest",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_abs_multiplied_positions": {
          "description": "The accumulated absolute multiplied positions, calculated for open positions as: pos_1_size * |pos_1_size| + pos_2_size * |pos_2_size| + ... if a position is closed, the accumulated absolute multiplied position is removed from the accumulator: pos_1_size * |pos_1_size| + pos_2_size * |pos_2_size| + ... - pos_1_size * |pos_1_size|",
          "allOf": [
            {
              "$ref": "#/definitions/Int256"
            }
          ]
        },
        "total_entry_cost": {
          "description": "The accumulated entry cost, calculated for open positions as: pos_1_size * pos_1_entry_exec_price + pos_2_size * pos_2_entry_exec_price + ... if a position is closed, the accumulated entry cost is removed from the accumulator: pos_1_size * pos_1_entry_exec_price + pos_2_size * pos_2_entry_exec_price + ... - pos_1_size * pos_1_entry_exec_price pos_2_size * pos_2_entry_exec_price + ...",
          "allOf": [
            {
              "$ref": "#/definitions/Int128"
            }
          ]
        },
        "total_entry_funding": {
          "description": "The accumulated entry funding, calculated for open positions as: pos_1_size * pos_1_entry_funding + pos_2_size * pos_2_entry_funding + ... if a position is closed, the accumulated entry funding is removed from the accumulator: pos_1_size * pos_1_entry_funding + pos_2_size * pos_2_entry_funding + ... - pos_1_size * pos_1_entry_funding pos_2_size * pos_2_entry_funding + ...",
          "allOf": [
            {
              "$ref": "#/definitions/Int128"
            }
          ]
        },
        "total_squared_positions": {
          "description": "The accumulated squared positions, calculated for open positions as: pos_1_size^2 + pos_2_size^2 + ... if a position is closed, the accumulated squared position is removed from the accumulator: pos_1_size^2 + pos_2_size^2 + ... - pos_1_size^2",
          "allOf": [
            {
              "$ref": "#/definitions/Uint256"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "protocol_fee"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            },
            "protocol_fee": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Funding": {
          "description": "Funding parameters for a single denom.\n\nThe role of funding rates is generally to balance long and short demand. Traders will either pay or receive funding rates, depending on their positions. If the funding rate is positive, long position holders will pay the funding rate to those holding short positions, and vice versa.",
          "type": "object",
          "required": [
            "last_funding_accrued_per_unit_in_base_denom",
            "last_funding_rate",
            "max_funding_velocity",
            "skew_scale"
          ],
          "properties": {
            "last_funding_accrued_per_unit_in_base_denom": {
              "description": "Last funding accrued per unit",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "last_funding_rate": {
              "description": "The current funding rate calculated as an 24-hour rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "max_funding_velocity": {
              "description": "Determines the maximum rate at which funding can be adjusted",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "skew_scale": {
              "description": "Determines the funding rate for a given level of skew. The lower the skew_scale the higher the funding rate.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "Int256": {
          "description": "An implementation of i256 that is using strings for JSON encoding/decoding, such that the full i256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Int256; let a = Int256::from(258u128); let b = Int256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        },
        "SignedDecimal": {
          "description": "A signed fixed-point decimal value with 18 fractional digits, i.e. SignedDecimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 170141183460469231731.687303715884105727 (which is (2^127 - 1) / 10^18) and the smallest is -170141183460469231731.687303715884105728 (which is -2^127 / 10^18).",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint256": {
          "description": "An implementation of u256 that is using strings for JSON encoding/decoding, such that the full u256 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances out of primitive uint types or `new` to provide big endian bytes:\n\n``` # use cosmwasm_std::Uint256; let a = Uint256::from(258u128); let b = Uint256::new([ 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8, ]); assert_eq!(a, b); ```",
          "type": "string"
        }
      }
    },
    "markets": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PaginationResponse_for_MarketResponse",
      "type": "object",
      "required": [
        "data",
        "metadata"
      ],
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MarketResponse"
          }
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "MarketResponse": {
          "description": "Market state for a single denom",
          "type": "object",
          "required": [
            "current_funding_rate",
            "denom",
            "enabled",
            "long_oi",
            "long_oi_value",
            "short_oi",
            "short_oi_value"
          ],
          "properties": {
            "current_funding_rate": {
              "description": "Current funding rate",
              "allOf": [
                {
                  "$ref": "#/definitions/SignedDecimal"
                }
              ]
            },
            "denom": {
              "description": "Denomination of the asset",
              "type": "string"
            },
            "enabled": {
              "description": "Enabled status of the market",
              "type": "boolean"
            },
            "long_oi": {
              "description": "Total LONG open interest in utokens",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "long_oi_value": {
              "description": "Total LONG open interest in oracle base currency (uusd)",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "short_oi": {
              "description": "Total SHORT open interest in utokens",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "short_oi_value": {
              "description": "Total SHORT open interest in oracle base currency (uusd)",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Metadata": {
          "type": "object",
          "required": [
            "has_more"
          ],
          "properties": {
            "has_more": {
              "type": "boolean"
            }
          },
          "additionalProperties": false
        },
        "SignedDecimal": {
          "description": "A signed fixed-point decimal value with 18 fractional digits, i.e. SignedDecimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 170141183460469231731.687303715884105727 (which is (2^127 - 1) / 10^18) and the smallest is -170141183460469231731.687303715884105728 (which is -2^127 / 10^18).",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "opening_fee": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TradingFee",
      "type": "object",
      "required": [
        "fee",
        "rate"
      ],
      "properties": {
        "fee": {
          "$ref": "#/definitions/Coin"
        },
        "rate": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OwnerResponse",
      "description": "Returned from Owner.query()",
      "type": "object",
      "required": [
        "abolished",
        "initialized"
      ],
      "properties": {
        "abolished": {
          "type": "boolean"
        },
        "emergency_owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "initialized": {
          "type": "boolean"
        },
        "owner": {
          "type": [
            "string",
            "null"
          ]
        },
        "proposed": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionResponse",
      "type": "object",
      "required": [
        "account_id"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "position": {
          "anyOf": [
            {
              "$ref": "#/definitions/PerpPosition"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "current_exec_price",
            "current_price",
            "denom",
            "entry_exec_price",
            "entry_price",
            "realized_pnl",
            "size",
            "unrealized_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "current_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realized_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            },
            "size": {
              "$ref": "#/definitions/Int128"
            },
            "unrealized_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            }
          },
          "additionalProperties": false
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/Int128"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "position_fees": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionFeesResponse",
      "type": "object",
      "required": [
        "base_denom",
        "closing_fee",
        "opening_fee"
      ],
      "properties": {
        "base_denom": {
          "description": "Denomination of the base asset",
          "type": "string"
        },
        "closing_exec_price": {
          "description": "Closing execution price of the position calculated with: - entry size if the position is closed or reduced",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "closing_fee": {
          "description": "The fee charged when closing/reducing a position",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "opening_exec_price": {
          "description": "Opening execution price of the position calculated with: - entry size if the position is opened - new size if the position is increased or reduced",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "opening_fee": {
          "description": "The fee charged when opening/increasing a position",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PositionResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PositionResponse"
      },
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "current_exec_price",
            "current_price",
            "denom",
            "entry_exec_price",
            "entry_price",
            "realized_pnl",
            "size",
            "unrealized_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "current_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realized_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            },
            "size": {
              "$ref": "#/definitions/Int128"
            },
            "unrealized_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            }
          },
          "additionalProperties": false
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/Int128"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        },
        "PositionResponse": {
          "type": "object",
          "required": [
            "account_id"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "position": {
              "anyOf": [
                {
                  "$ref": "#/definitions/PerpPosition"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "positions_by_account": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsByAccountResponse",
      "type": "object",
      "required": [
        "account_id",
        "positions"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "positions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PerpPosition"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "PerpPosition": {
          "description": "This is the position data to be returned in a query. It includes current price and PnL.",
          "type": "object",
          "required": [
            "base_denom",
            "current_exec_price",
            "current_price",
            "denom",
            "entry_exec_price",
            "entry_price",
            "realized_pnl",
            "size",
            "unrealized_pnl"
          ],
          "properties": {
            "base_denom": {
              "type": "string"
            },
            "current_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "current_price": {
              "$ref": "#/definitions/Decimal"
            },
            "denom": {
              "type": "string"
            },
            "entry_exec_price": {
              "$ref": "#/definitions/Decimal"
            },
            "entry_price": {
              "$ref": "#/definitions/Decimal"
            },
            "realized_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            },
            "size": {
              "$ref": "#/definitions/Int128"
            },
            "unrealized_pnl": {
              "$ref": "#/definitions/PnlAmounts"
            }
          },
          "additionalProperties": false
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/Int128"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "realized_pnl_by_account_and_market": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PnlAmounts",
      "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
      "type": "object",
      "required": [
        "accrued_funding",
        "closing_fee",
        "opening_fee",
        "pnl",
        "price_pnl"
      ],
      "properties": {
        "accrued_funding": {
          "$ref": "#/definitions/Int128"
        },
        "closing_fee": {
          "$ref": "#/definitions/Int128"
        },
        "opening_fee": {
          "$ref": "#/definitions/Int128"
        },
        "pnl": {
          "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
          "allOf": [
            {
              "$ref": "#/definitions/Int128"
            }
          ]
        },
        "price_pnl": {
          "$ref": "#/definitions/Int128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        }
      }
    },
    "total_accounting": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AccountingResponse",
      "description": "Represents the vault's accounting data and unrealized profit and loss (PnL), all denominated in the base currency (e.g. UUSDC).",
      "type": "object",
      "required": [
        "accounting",
        "unrealized_pnl"
      ],
      "properties": {
        "accounting": {
          "description": "The vault's accounting data. Negative values indicate the vault is losing money, meaning traders are in profit.",
          "allOf": [
            {
              "$ref": "#/definitions/Accounting"
            }
          ]
        },
        "unrealized_pnl": {
          "description": "Unrealized PnL amounts for all open positions. Negative unrealized PnL indicates traders are losing money, meaning the vault is in profit.",
          "allOf": [
            {
              "$ref": "#/definitions/PnlAmounts"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Accounting": {
          "description": "Represents the accounting data for the vault, denominated in the base currency (e.g. UUSDC). If the values are negative, it indicates the vault is losing money.",
          "type": "object",
          "required": [
            "balance",
            "cash_flow",
            "withdrawal_balance"
          ],
          "properties": {
            "balance": {
              "description": "The total balance, which includes both realized and unrealized amounts.",
              "allOf": [
                {
                  "$ref": "#/definitions/Balance"
                }
              ]
            },
            "cash_flow": {
              "description": "The realized amount of money, only includes completed payments.",
              "allOf": [
                {
                  "$ref": "#/definitions/CashFlow"
                }
              ]
            },
            "withdrawal_balance": {
              "description": "The amount available for withdrawal by liquidity providers (LPs). This value may cap certain unrealized payments.",
              "allOf": [
                {
                  "$ref": "#/definitions/Balance"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Balance": {
          "description": "Amount of money denominated in the base denom (e.g. UUSDC) used for accounting",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "total"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            },
            "total": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        },
        "CashFlow": {
          "description": "The actual amount of money denominated in the base denom (e.g. UUSDC), includes only realized payments",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "price_pnl",
            "protocol_fee"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            },
            "protocol_fee": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "PnlAmounts": {
          "description": "Amounts denominated in the Perp Vault base denom (uusdc)",
          "type": "object",
          "required": [
            "accrued_funding",
            "closing_fee",
            "opening_fee",
            "pnl",
            "price_pnl"
          ],
          "properties": {
            "accrued_funding": {
              "$ref": "#/definitions/Int128"
            },
            "closing_fee": {
              "$ref": "#/definitions/Int128"
            },
            "opening_fee": {
              "$ref": "#/definitions/Int128"
            },
            "pnl": {
              "description": "PnL: price PnL + accrued funding + opening fee + closing fee",
              "allOf": [
                {
                  "$ref": "#/definitions/Int128"
                }
              ]
            },
            "price_pnl": {
              "$ref": "#/definitions/Int128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "vault": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VaultResponse",
      "type": "object",
      "required": [
        "total_balance",
        "total_debt",
        "total_liquidity",
        "total_shares",
        "total_unlocking_or_unlocked_amount",
        "total_unlocking_or_unlocked_shares",
        "total_withdrawal_balance"
      ],
      "properties": {
        "collateralization_ratio": {
          "description": "Collateralization ratio of the vault. `collateralization_ratio = total_liquidity / total_debt` None if `total_debt` is zero.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "share_price": {
          "description": "Vault share price is calculated directly from the total withdrawal balance and the shares supply. `share_price = total_withdrawal_balance / total_shares` None if `total_shares` is zero.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "total_balance": {
          "description": "Value of the total balance in the base denom. This is the total amount of the base denom deposited to the vault by liquidity providers. The value is updated when a user deposits or withdraws from the vault. The value can be negative if the liquidity providers withdraw more than the total balance. This can happen if the vault earns a profit from trading.",
          "allOf": [
            {
              "$ref": "#/definitions/Int128"
            }
          ]
        },
        "total_debt": {
          "description": "Positive total unrealized PnL that the vault owes to the users. `total_debt = max(total_unrealized_pnl, 0)`",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_liquidity": {
          "description": "Total liquidity in the base denom aggregated across all markets. `total_liquidity = max(total_balance + accounting.cash_flow.total, 0)` See [`Accounting`] for more details regarding the calculation of `accounting.cash_flow.total`.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_shares": {
          "description": "Total shares minted to liquidity providers.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_unlocking_or_unlocked_amount": {
          "description": "The total amount (in base currency) corresponding to shares that are either unlocking or already unlocked but not withdrawn. This amount is proportional to the total unlocking or unlocked shares and is calculated based on the Vault share price.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_unlocking_or_unlocked_shares": {
          "description": "The total number of shares that are either currently unlocking or already unlocked but not withdrawn. This includes both shares still within the unlocking period and shares that have completed unlocking.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "total_withdrawal_balance": {
          "description": "Total withdrawal balance in the base denom aggregated across all markets. `total_withdrawal_balance = max(total_balance + accounting.withdrawal_balance.total, 0)` See [`Accounting`] for more details regarding the calculation of `accounting.withdrawal_balance.total`.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Int128": {
          "description": "An implementation of i128 that is using strings for JSON encoding/decoding, such that the full i128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `i128` to get the value out:\n\n``` # use cosmwasm_std::Int128; let a = Int128::from(258i128); assert_eq!(a.i128(), 258); ```",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "vault_position": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_VaultPositionResponse",
      "anyOf": [
        {
          "$ref": "#/definitions/VaultPositionResponse"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "VaultDeposit": {
          "type": "object",
          "required": [
            "amount",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "VaultPositionResponse": {
          "type": "object",
          "required": [
            "denom",
            "deposit",
            "unlocks"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "deposit": {
              "$ref": "#/definitions/VaultDeposit"
            },
            "unlocks": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/VaultUnlock"
              }
            }
          },
          "additionalProperties": false
        },
        "VaultUnlock": {
          "type": "object",
          "required": [
            "amount",
            "cooldown_end",
            "created_at",
            "shares"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "cooldown_end": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
